package edu.kit.informatik;
import java.util.ArrayList;
/**
 * This class contains the graph of the airports, it's adjacency matrix and it's distance matrix
 * @author Ahmad
 * @version 1.0
 */
public class Graph {
    /**
     * The list of all airports inserted using the method insertAirpot().
     */
    ArrayList<Airport> airports;
    /**
     * The adjacency Matrix
     */
    int [][] adjacencyMatrix;
    /**
     * The distance Matrix
     */
    int [][] distanceMatrix;
    /**
     * Constructor initializes the the ArrayList<Airport> airports.
     */
    public Graph() {
        airports = new ArrayList<Airport>();
    }
    /**
     * This method initialize the adjacency Matrix and the distance Matrix,
     * this method is going to be used after the creating the airports and their routes.
     */
    public void refreshMatrices() {
        adjacencyMatrix();
        distanceMatrix();
    }
    /**
     * This method represents the first part of serializing, it inserts an object airport in the
     * ArrayList<Airport> airports,
     * @param line airportDetails[0] is the IATA code, airportDetails[1] is the airports name.
     */
    public void insertAirport(String line) {
        System.out.println(line);
        if (!line.matches("[A-Z]{3};[A-Z][A-Za-z]*")) {
            throw new IllegalArgumentException("Error, during inserting an airport."
                    + "the name and the IATA code must match the pattern [a-zA-Z_-]+");
        }
        String[] airportDetails = line.split(";");
        if (airportDetails.length != 2) {
            throw new IllegalArgumentException("Error, during inserting an airport."
                    + "only the name and the IATA code of the airports are needed");
        }
        if (searchForAirportName(airportDetails[1]) != null) {
            throw new IllegalArgumentException("Error, during inserting an airport."
                    + "an airport exists with the name: " + airportDetails[0]);
        } else if (searchForIATA(airportDetails[0]) != null) {
            throw new IllegalArgumentException("Error, during inserting an airport."
                    + "an airport exists with the IATA code: " + airportDetails[1]);
        } else {
            airports.add(new Airport(airportDetails[0], airportDetails[1]));
            System.out.println("inserted");
        }
    }
    /**
     * This method represents the second part of serializing, it fills in the reachable cities for 
     * airports in the graph.
     * @param line flightRoute[0] is the starting airport, flightRoute[1] is the destination flight
     * flightRoute[2] is the distance.
     * destination airport and flightRoute[2] is the distance.
     */
    public void flightRoutes(String line) {
        if (!line.matches("[A-Z]{3};[A-Z]{3};[0-9]+")) {
            throw new IllegalArgumentException("");
        }
        String[] flightRoute = line.split(";");
        int distance = Integer.parseInt(flightRoute[2]);
        if (distance <= 0) {
            throw new IllegalArgumentException("Error, during connecting airports, distance cannot be"
                    + "zero or smaller ");
        }
        //Check in interactive: if the length is 2, distance must be greater than zero, integer parse!
        if (searchForIATA(flightRoute[0]) == null) {
            throw new IllegalArgumentException("Error, during connecting airports, the Starting airport: " 
                    + flightRoute[0] + ", doesn't exist.");
        } else if (searchForIATA(flightRoute[1]) == null) {
            throw new IllegalArgumentException("Error, during connecting airports, the destination airport: " 
                    + flightRoute[1] + ", doesn't exist.");
        } else if (distance < 0) {
            throw new IllegalArgumentException("Error, during connecting airports, distance must be "
                    + "greater than zero");
        } else {
            searchForIATA(flightRoute[0]).addRoute(new Route(searchForIATA(flightRoute[1]), distance));
        }
    }
    /**
     * This method transforms the graph into the adjacency Matrix.
     * @return adjacency Matrix.
     */
    public int[][] adjacencyMatrix() {
        adjacencyMatrix = new int[airports.size()][airports.size()];
        for (int i = 0; i < airports.size(); i++) {
            for (int j = 0; j < airports.size(); j++) {
                int distance = distanceFinder(airports.get(i), airports.get(j));
                adjacencyMatrix[i][j] = (distance > 0) ? 1 : 0;
            }
        }
        return adjacencyMatrix;
    }
    /**
     * This method transforms the graph into the distance Matrix.
     * @return the distance Matrix
     */
    public int[][] distanceMatrix() {
        distanceMatrix = new int[airports.size()][airports.size()];
        for (int i = 0; i < airports.size(); i++) {
            for (int j = 0; j < airports.size(); j++) {
                distanceMatrix[i][j] = distanceFinder(airports.get(i), airports.get(j));
            }
        }
        return distanceMatrix;
    }
    /**
     * This method transforms the adjacency matrix 
     * @param stopOvers
     * @return
     */
    public int[][] routesMatrix(int stopOvers) {
        if (stopOvers <= 0 ||  stopOvers > airports.size()) {
            throw new IllegalArgumentException("Error, during finding the number of routes stop ."
                    + "overs cannot be smaller than zero or greater than the number of airports.");
        }
        int length = airports.size();
        int [][] template = copyArray(adjacencyMatrix);
        int[][] routeMatrix = new int[length][length];
        //if stopover is zero, that's a fucking problem.
        for (int iterate = 0; iterate < stopOvers - 1; iterate++) {
            for (int i = 0; i < length; i++) {
                for (int k = 0; k < length; k++) {
                    for (int j = 0; j < length; j++) {
                        routeMatrix[i][j] += template[i][k] * adjacencyMatrix[k][j];
                    }
                }
            }
        }
        return routeMatrix;
    }
    public double[][] shortestPath() {
        double [][] shortestPath = intArrayToDouble(distanceMatrix);
        for ( int i = 0; i < distanceMatrix.length; i++) {
            for (int j = 0; j < distanceMatrix.length; j++) {
                for (int k = 0; k < distanceMatrix.length; k++) {
                    shortestPath[i][j] = Math.min(shortestPath[i][j], shortestPath[i][k] + shortestPath[k][j]);
                }
            }
        }
        return shortestPath;
    }
    /**
     * This method searches for an airport using the airport's name.
     * @param airportName airportDetails[0] is the IATA code, airportDetails[1] is the airports name.
     * @return the airport, that has the airportName from the list of airports, otherwise returns null.
     */
    public Airport searchForAirportName(String airportName) {
        if (!airports.isEmpty()) {
            for (Airport airport : airports) {
                System.out.println(airport.getAirportName());
                if (airport.getAirportName().equals(airportName)) {
                    return airport;
                }
            }
        }
        return null;
    }
    public Airport searchForIATA(String IATA) {
        for (Airport airport : airports) {
            if (airport.getIATACode().equals(IATA)) {
                return airport;
            }
        }
        return null;
    }
    public int distanceFinder(Airport start, Airport end) {
        for (Route route : start.getReachableCities()) {
            if (route.getDestination() == end) {
                return route.getDistance();
            }
        }
        return -1;
    }
    public int[][] copyArray(int[][] array) {
        int[][] toBeReturned = new int[array.length][array.length];
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length; j++) {
                toBeReturned[i][j] = array[i][j];
            }
        }
        return toBeReturned;
    }
    public double[][] intArrayToDouble(int[][] array) {
        double[][] toBeReturned = new double[array.length][array.length];
        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array.length; j++) {
                toBeReturned[i][j] = (array[i][j] < 0) ? Double.POSITIVE_INFINITY 
                        : (double) array[i][j];
            }
        }
        return toBeReturned;
    }
}
